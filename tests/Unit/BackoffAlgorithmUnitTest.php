<?php

declare(strict_types=1);

namespace CodeDistortion\Backoff\Tests\Unit;

use CodeDistortion\Backoff\Algorithms\CallbackBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\DecorrelatedBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\ExponentialBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\FibonacciBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\FixedBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\LinearBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\NoBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\NoopBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\PolynomialBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\RandomBackoffAlgorithm;
use CodeDistortion\Backoff\Algorithms\SequenceBackoffAlgorithm;
use CodeDistortion\Backoff\Exceptions\BackoffInitialisationException;
use CodeDistortion\Backoff\Exceptions\BackoffRuntimeException;
use CodeDistortion\Backoff\Interfaces\BackoffAlgorithmInterface;
use CodeDistortion\Backoff\Support\BaseBackoffAlgorithm;
use CodeDistortion\Backoff\Tests\PHPUnitTestCase;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Test;
use stdClass;

/**
 * Test the BackoffAlgorithm classes.
 *
 * @phpcs:disable PSR1.Methods.CamelCapsMethodName.NotCamelCaps
 */
class BackoffAlgorithmUnitTest extends PHPUnitTestCase
{
    /**
     * Test the delay sequences generated by the different backoff strategies.
     *
     * @test
     * @dataProvider backoffAlgorithmDataProvider
     *
     * @param callable                   $createAlgorithm Callback to instantiate the Algorithm to test.
     * @param array<integer|float|false> $expected        The expected delays that should be generated.
     * @return void
     */
    #[Test]
    #[DataProvider('backoffAlgorithmDataProvider')]
    public static function test_backoff_algorithm_generated_sequences(callable $createAlgorithm, array $expected): void
    {
        /** @var BaseBackoffAlgorithm $algorithmInstance */
        $algorithmInstance = $createAlgorithm();
        self::assertSame($expected, $algorithmInstance->generateTestSequence(count($expected)));
    }

    /**
     * DataProvider for test_normalisation_of_time_inputs.
     *
     * @return array<array<callable|array<integer|float|null>>>
     */
    public static function backoffAlgorithmDataProvider(): array
    {
        $integerCallback = fn(int $retryCount) => $retryCount * 10;
        $floatCallback = fn(int $retryCount) => $retryCount * 1.5;
        $nullCallback = fn(int $retryCount) => null;
        $prevDelayCallback = fn(int $retryCount, int|float|null $prevBaseDelay) => is_numeric($prevBaseDelay)
            ? $prevBaseDelay + 2
            : 2;

        /** @var array<integer|float> $delaysWithNull */
        $delaysWithNull = [1, 2, null, 4, 5]; // pretend this is typed as array<integer|float> for static analysis

        // Note: that bounding (between 0 and max-delay), max-attempts, jitter and rounding
        // to the nearest int for milliseconds and microseconds aren't tested here

        return [

            // FixedBackoffAlgorithm
            [
                fn() => new FixedBackoffAlgorithm(-1), // negative delay
                [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
            ],
            [
                fn() => new FixedBackoffAlgorithm(0), // zero delay
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new FixedBackoffAlgorithm(1),
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ],
            [
                fn() => new FixedBackoffAlgorithm(2),
                [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            ],
            [
                fn() => new FixedBackoffAlgorithm(1.5), // float delay
                [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5],
            ],



            // LinearBackoffAlgorithm
            // initial delay only (1 parameter)
            [
                fn() => new LinearBackoffAlgorithm(-1), // negative initial delay
                [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],
            ],
            [
                fn() => new LinearBackoffAlgorithm(0), // zero initial delay
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new LinearBackoffAlgorithm(1),
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            ],
            [
                fn() => new LinearBackoffAlgorithm(2),
                [2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
            ],
            [
                fn() => new LinearBackoffAlgorithm(1.5), // float initial delay
                [1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5, 15.0],
            ],
            // initial delay + delay increase (2 parameters)
            [
                fn() => new LinearBackoffAlgorithm(1, null), // null delay increase
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            ],
            [
                fn() => new LinearBackoffAlgorithm(5, -1), // negative delay increase
                [5, 4, 3, 2, 1, 0, -1, -2, -3, -4],
            ],
            [
                fn() => new LinearBackoffAlgorithm(1, 0),
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ],
            [
                fn() => new LinearBackoffAlgorithm(1, 1),
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            ],
            [
                fn() => new LinearBackoffAlgorithm(1, 2),
                [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],
            ],
            [
                fn() => new LinearBackoffAlgorithm(10, 1.5), // float delay increase
                [10.0, 11.5, 13.0, 14.5, 16.0, 17.5, 19.0, 20.5, 22.0, 23.5],
            ],



            // ExponentialBackoffAlgorithm
            // initial delay only (1 parameter)
            [
                fn() => new ExponentialBackoffAlgorithm(-1), // negative initial delay
                [-1, -2, -4, -8, -16, -32, -64, -128, -256, -512],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(0), // zero initial delay
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(1),
                [1, 2, 4, 8, 16, 32, 64, 128, 256, 512],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(2),
                [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(1.5), // float initial delay
                [1.5, 3.0, 6.0, 12.0, 24.0, 48.0, 96.0, 192.0, 384.0, 768.0],
            ],
            // initial delay + increase factor (2 parameters)
            [
                fn() => new ExponentialBackoffAlgorithm(1, -1), // negative increase factor
                [1, -1, 1, -1, 1, -1, 1, -1, 1, -1],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(1, 0), // zero increase factor
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(1, 2),
                [1, 2, 4, 8, 16, 32, 64, 128, 256, 512],
            ],
            [
                fn() => new ExponentialBackoffAlgorithm(1, 1.5), // float increase factor
                [1.0, 1.5, 2.25, 3.375, 5.0625, 7.59375, 11.390625, 17.0859375, 25.62890625, 38.443359375],
            ],



            // PolynomialBackoffAlgorithm
            // initial delay only (1 parameter)
            [
                fn() => new PolynomialBackoffAlgorithm(-1), // negative initial delay
                [-1, -4, -9, -16, -25, -36, -49, -64, -81, -100],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(0), // zero initial delay
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1),
                [1, 4, 9, 16, 25, 36, 49, 64, 81, 100],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1.5), // float initial delay
                [1.5, 6.0, 13.5, 24.0, 37.5, 54.0, 73.5, 96.0, 121.5, 150.0],
            ],
            // initial delay + power (2 parameters)
            [
                fn() => new PolynomialBackoffAlgorithm(1, -1), // negative power
                [
                    1.0,
                    0.5,
                    0.3333333333333333,
                    0.25,
                    0.2,
                    0.16666666666666666,
                    0.14285714285714285,
                    0.125,
                    0.1111111111111111,
                    0.1,
                ],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1, 0), // zero power
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1, 1),
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1, 2),
                [1, 4, 9, 16, 25, 36, 49, 64, 81, 100],
            ],
            [
                fn() => new PolynomialBackoffAlgorithm(1, 1.4), // float power
                [
                    1.0,
                    2.6390158215457884,
                    4.655536721746079,
                    6.964404506368992,
                    9.518269693579391,
                    12.286035066475314,
                    15.245344971379456,
                    18.379173679952558,
                    21.674022167526225,
                    25.118864315095795,
                ],
            ],



            // FibonacciBackoffAlgorithm
            // initial delay only (1 parameter)
            [
                fn() => new FibonacciBackoffAlgorithm(-1), // negative initial delay
                [-1, -1, -2, -3, -5, -8, -13, -21, -34],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(0), // zero initial delay
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1),
                [1, 1, 2, 3, 5, 8, 13, 21, 34],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(2),
                [2, 2, 4, 6, 10, 16, 26, 42, 68],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1234), // large initial delay
                [1234, 1234, 2468, 3702, 6170, 9872, 16042, 25914, 41956],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1.5), // float initial delay
                [1.5, 1.5, 3.0, 4.5, 7.5, 12.0, 19.5, 31.5, 51.0],
            ],
            // initial delay + include or exclude the first in the fibonacci sequence (2 parameters)
            [
                fn() => new FibonacciBackoffAlgorithm(1, false), // exclude the first
                [1, 2, 3, 5, 8, 13, 21, 34, 55],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1, true), // include the first
                [1, 1, 2, 3, 5, 8, 13, 21, 34, 55],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1.5, false), // include the first
                [1.5, 3.0, 4.5, 7.5, 12.0, 19.5, 31.5, 51.0, 82.5, 133.5],
            ],
            [
                fn() => new FibonacciBackoffAlgorithm(1.5, true), // include the first
                [1.5, 1.5, 3.0, 4.5, 7.5, 12.0, 19.5, 31.5, 51.0, 82.5],
            ],



            // SequenceBackoffAlgorithm
            // sequence only (1 parameter)
            [
                fn() => new SequenceBackoffAlgorithm([]), // empty sequence
                [null, null, null, null, null, null, null, null, null, null],
            ],
            [
                fn() => new SequenceBackoffAlgorithm([], true), // empty sequence with repeat
                [null, null, null, null, null, null, null, null, null, null],
            ],
            [
                fn() => new SequenceBackoffAlgorithm($delaysWithNull),
                [1, 2, null, null, null, null, null, null, null, null],
            ],
            [
                fn() => new SequenceBackoffAlgorithm([1, 2, 3, 4, 5]),
                [1, 2, 3, 4, 5, null, null, null, null, null],
            ],
            [
                fn() => new SequenceBackoffAlgorithm([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]),
                [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
            ],
            [
                fn() => new SequenceBackoffAlgorithm(
                    [1, 10, 2, 9, 3, 8, 4, 7, 5, 6, 6, 5, 7, 4, 8, 3, 9, 2, 10, 1] // more than 10 values
                ),
                [1, 10, 2, 9, 3, 8, 4, 7, 5, 6],
            ],
            // sequence + repeat = false (2 parameters)
            [
                fn() => new SequenceBackoffAlgorithm([1, 2, 3, 4, 5], false),
                [1, 2, 3, 4, 5, null, null, null, null, null],
            ],
            // sequence + repeat = true (2 parameters)
            [
                fn() => new SequenceBackoffAlgorithm([1, 2, 3, 4, 5], true),
                [1, 2, 3, 4, 5, 5, 5, 5, 5, 5],
            ],
            // sequence indexed incorrectly
            [
                fn() => new SequenceBackoffAlgorithm([1 => 1, 0 => 0, 2 => 2], false),
                [1, 0, 2],
            ],



            // CallbackBackoffAlgorithm
            [
                fn() => new CallbackBackoffAlgorithm($integerCallback),
                [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],
            ],
            [
                fn() => new CallbackBackoffAlgorithm($floatCallback),
                [1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5, 15.0],
            ],
            [
                fn() => new CallbackBackoffAlgorithm($nullCallback),
                [null, null, null, null, null, null, null, null, null, null],
            ],
            [
                fn() => new CallbackBackoffAlgorithm($prevDelayCallback),
                [2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
            ],



            // NoBackoffAlgorithm
            [
                fn() => new NoBackoffAlgorithm(),
                [null, null, null, null, null, null, null, null, null, null],
            ],



            // NoopBackoffAlgorithm
            [
                fn() => new NoopBackoffAlgorithm(),
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ],
        ];
    }

    /**
     * Test the DecorrelatedBackoffAlgorithm.
     *
     * @test
     * @dataProvider decorrelatedDataProvider
     *
     * @param integer|float      $baseDelay  The initial delay to use.
     * @param integer|float|null $multiplier The factor to multiply by each time.
     * @return void
     */
    #[Test]
    #[DataProvider('decorrelatedDataProvider')]
    public static function test_decorrelated_backoff_algorithm(int|float $baseDelay, int|float|null $multiplier): void
    {
        $algorithm = !is_null($multiplier)
            ? new DecorrelatedBackoffAlgorithm($baseDelay, $multiplier)
            : new DecorrelatedBackoffAlgorithm($baseDelay); // use the default multiplier

        $multiplier = $multiplier ?? 3; // multiplier default is 3

        $prevDelay = $baseDelay;
        foreach ($algorithm->generateTestSequence(100) as $delay) {
            self::assertGreaterThanOrEqual($baseDelay, $delay);
            self::assertLessThanOrEqual($prevDelay * $multiplier, $delay);

            $prevDelay = is_numeric($delay)
                ? $delay
                : 0;
        }
    }

    /**
     * DataProvider for test_decorrelated_backoff_algorithm.
     *
     * @return array<array<int|float|int|null>>
     */
    public static function decorrelatedDataProvider(): array
    {
        return [
            [0, 1],
            [0.1, 1],
            [1, 1],
            [100, 1],

            [0, 1.1],
            [0.1, 1.1],
            [1, 1.1],
            [100, 1.1],

            [0, 2],
            [0.1, 2],
            [1, 2],
            [100, 2],

            [0, null], // multiplier default is 3
            [0.1, null],
            [1, null],
            [100, null],

            [0, 10],
            [0.1, 10],
            [1, 10],
            [100, 10],
        ];
    }



    /**
     * Test the DecorrelatedBackoffAlgorithm's use of the previous delay.
     *
     * @test
     *
     * @return void
     */
    #[Test]
    public static function test_decorrelated_backoff_algorithm_prev_delay_usage(): void
    {
        $algorithm = new DecorrelatedBackoffAlgorithm(2, 1);

        // check that it uses the base delay when there is no previous delay
        self::assertSame(2.0, $algorithm->calculateBaseDelay(1, null));

        // check that it uses the previous delay when there is one
        for ($count = 1; $count <= 10; $count++) {
            $delay = $algorithm->calculateBaseDelay(1, 10.0);
            self::assertGreaterThanOrEqual(2.0, $delay);
            self::assertLessThanOrEqual(10.0, $delay);
        }
    }

    /**
     * Test the DecorrelatedBackoffAlgorithm's constructor's default values.
     *
     * @test
     *
     * @return void
     */
    #[Test]
    public static function test_decorrelated_backoff_algorithm_default_values(): void
    {
        $baseDelay = 2;
        $prevBaseDelay = 4;
        $defaultMultiplier = 3;

        $algorithm = new DecorrelatedBackoffAlgorithm($baseDelay);

        // check that the delays it generates are within the expected range if the multiplier is 3
        $foundHighNumberCloseToDefaultMultiplier = false;
        for ($count = 1; $count <= 1000; $count++) {

            $delay = $algorithm->calculateBaseDelay(1, $prevBaseDelay);

            self::assertGreaterThanOrEqual($baseDelay, $delay);
            self::assertLessThanOrEqual($prevBaseDelay * $defaultMultiplier, $delay);

            if ($delay > $prevBaseDelay * ($defaultMultiplier - 0.25)) {
                $foundHighNumberCloseToDefaultMultiplier = true;
            }
        }

        self::assertTrue($foundHighNumberCloseToDefaultMultiplier);
    }



    /**
     * Test the RandomBackoffAlgorithm.
     *
     * @test
     *
     * @return void
     */
    #[Test]
    public static function test_random_backoff_algorithm(): void
    {
        $min = mt_rand(0, 100000);
        $max = mt_rand($min, $min + 10);
        $algorithm = new RandomBackoffAlgorithm($min, $max);

        // check the delays are within the min and max
        $delay = null;
        for ($retryNumber = 1; $retryNumber < 100; $retryNumber++) {
            $delay = $algorithm->calculateBaseDelay($retryNumber, $delay);
            self::assertGreaterThanOrEqual($min, $delay);
            self::assertLessThanOrEqual($max, $delay);
        }

        // mins and maxes that are <= 0, should always return 0's
        $algorithm = new RandomBackoffAlgorithm(-1, -1);
        self::assertSame(
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            $algorithm->generateTestSequence(10)
        );

        $algorithm = new RandomBackoffAlgorithm(-1, 0);
        self::assertSame(
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            $algorithm->generateTestSequence(10)
        );

        $algorithm = new RandomBackoffAlgorithm(0, 0);
        self::assertSame(
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            $algorithm->generateTestSequence(10)
        );
    }



    /**
     * Check to make sure the correct backoff strategies allow jitter.
     *
     * @test
     * @dataProvider jitterMayBeAppliedDataProvider
     *
     * @param BackoffAlgorithmInterface $algorithm The algorithm to test.
     * @param boolean                   $expected  The expected jitter setting.
     * @return void
     */
    #[Test]
    #[DataProvider('jitterMayBeAppliedDataProvider')]
    public static function test_which_backoff_strategies_allow_jitter(
        BackoffAlgorithmInterface $algorithm,
        bool $expected
    ): void {

        self::assertSame($expected, $algorithm->jitterMayBeApplied());
    }

    /**
     * DataProvider for test_which_backoff_strategies_allow_jitter.
     *
     * @return array<array{BackoffAlgorithmInterface, bool}>
     */
    public static function jitterMayBeAppliedDataProvider(): array
    {
        return [
            [new FixedBackoffAlgorithm(1), true],
            [new LinearBackoffAlgorithm(1), true],
            [new ExponentialBackoffAlgorithm(1), true],
            [new PolynomialBackoffAlgorithm(1), true],
            [new FibonacciBackoffAlgorithm(1), true],
            [new DecorrelatedBackoffAlgorithm(1, 3), false],
            [new RandomBackoffAlgorithm(1, 2), false],
            [new SequenceBackoffAlgorithm([1]), true],
            [new CallbackBackoffAlgorithm(fn(int $retryNumber) => 1), true],
            [new NoBackoffAlgorithm(), false],
            [new NoopBackoffAlgorithm(), false],
        ];
    }



    /**
     * Test that RandomBackoffAlgorithm throws an exception when max is less than min.
     *
     * @test
     *
     * @return void
     * @throws BackoffInitialisationException This will always be thrown.
     */
    #[Test]
    public function test_that_random_backoff_throws_exception_when_max_is_less_than_min(): void
    {
        $this->expectException(BackoffInitialisationException::class);

        new RandomBackoffAlgorithm(1, 0);
    }



    /**
     * Test that CallbackBackoffAlgorithm throws exceptions when an invalid response is given.
     *
     * @test
     * @dataProvider invalidCallbackReturnValueDataProvider
     *
     * @param mixed $invalidReturnValue The invalid return value to test.
     * @return void
     * @throws BackoffRuntimeException This will always be thrown.
     */
    #[Test]
    #[DataProvider('invalidCallbackReturnValueDataProvider')]
    public function test_that_custom_backoff_throws_exceptions(mixed $invalidReturnValue): void
    {
        $this->expectException(BackoffRuntimeException::class);

        $algorithm = new CallbackBackoffAlgorithm(fn(int $retryCount) => $invalidReturnValue);
        $algorithm->calculateBaseDelay(1, null);
    }

    /**
     * DataProvider for test_that_custom_backoff_throws_exceptions.
     *
     * @return array{array{'not a number'}, array{stdClass}, array{array{}}, array{true}, array{false}}
     */
    public static function invalidCallbackReturnValueDataProvider(): array
    {
        return [
            ['not a number'],
            [new stdClass()],
            [[]],
            [true],
            [false],
        ];
    }
}
